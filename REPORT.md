# Implementation of Linear Predictive Coding (LPC) for Speech Analysis and Synthesis

## *Created by Corinne Darche for MUMT307: Music and Audio Computing II (Winter 2022)*

### Project Description: What is LPC?

Linear Predictive Coding (LPC) is a method for analyzing signals quickly and accurately. As described by O'Shaughnessy (1998), LPC's main draw is that it can accurately estimate vocal fold vibration, the vocal tract's shape, and the different vocal tract resonances with a small number of coefficients. Sawant et al. (2010) go onto explain that LPC's technique predicts a small number of coefficients, which represent speech parameters, that are then applied in digital filters to create a synthetic version of the original signal.
	
This MATLAB script implements a version of the LPC algorithm to analyze and resynthesize an audio file, either with real-time I/O, pre-recorded and saved files, or a combination of the two.

### Project Goals

1. Learn more about speech synthesis. Most of my experience with language processing is through the lens of text-based NLP, so this is a natural next step.
   - From the title of this course, this class mostly focuses on pitched sounds. However, if you take a look at the literature surrounding singing voice generation and analysis, the roots come from speech processing. Singing generation is still a huge challenge and research topic in sound synthesis, so a strong understanding of speech generation concepts is a must.
2. Create a program that can resynthesize a speech signal as a "parroting" effect
   - More importantly, is this even possible in MATLAB?
3. Learn more about Linear Predictive Coding
   - It's one of the most popular speech synthesis algorithms for a reason.

### Methodology and Design

The script follows a basic implementation of the LPC algorithm. I started off using the version described in MATLAB's DSP Toolbox documentation. However, I wanted to use as little of the toolbox as possible, since it's a black box and it would hinder the learning experience. 
	
The audio I/O options are activated with boolean statements. By default, they're both left as "false", meaning that the user inputs a file that they want synthesized and it is saved at the end. To prevent the script from crashing, there are mechanisms in place to make sure that the user inputs a valid file name or file path. The complete audio file is divided into frames (defined in the script as 1600) that the algorithm goes through one by one during the analysis.
	
The LPC algorithm can be divided into different sections. First, there's pre-emphasis, where the signal is filtered to give it a smoother spectral shape. This is done using an FIR filter of the form `y[n]=x[n]−ax[n−1]` where `0.9<a<1.0`. The smaller the value of a, the lower the quality is of the final synthesized version. Then, the signal passes through a Hanning window to further smooth it for analysis. It passes through a 12th order autocorrelation sequence before the reflection coefficients and error are calculated using the Levinson-Durbin algorithm.
	
The pre-emphasized signal and the resulting Levinson-Durbin coefficients are then passed through two lattice filters, one a finite impulse response (FIR) and the other an infinite impulse response (IIR) to reconstruct the original signal frame by frame. Taken from the MATLAB documentation, there is also an option to view the scope of the signal as well as the curve generated by the LPC coefficients.

### Discussion (Challenges, Successes, etc.)

This was a challenging subject to learn as an "outsider". It seemed like every resource that I opened skipped way too many steps or got lost in the mathematical theory. Sources that did show an implementation, like MATLAB's MathWorks documentation, did it in a black-box method. That is, there was no way to see what exactly was happening underneath those functions. Yes, the final product worked, but there was no increased understanding on my part. This meant that I had to get creative and do some extra reading and digging to figure out how to implement this on my own.
	
Most literature that I found insisted on using a Hamming window to smooth out the signal. Based on what we've learned about windowing techniques, it's a logical choice since it smooths out the envelope and doesn't create a sharp ending on any of the frames. To further confirm my understanding, I tried swapping it out for a rectangular window or a triangular window, only to find that the output would get abruptly cut off before the end of the input file. 
	
In my initial plan, I wanted to create a GUI for the script and turn it into a proper application. However, creating a GUI using MATLAB's interface is not intuitive as the language isn't built for that. I also wanted to focus less on creating a nice UI and stick to the main objective of this project. As such, a simple MATLAB script with user I/O seemed to be the ideal design choice.
	
Aside from these challenges, I found it rewarding to be able to learn this subject from the ground up. I also got genuinely excited when my implementation worked and the generated sound played. The one issue that I see with my implementation is the file size. LPC promises a synthesized signal at a reduced bit rate. However, when seeing my implementation, I notice that my generated files are significantly larger than my pre-recorded ones. There is a possibility that Apple's algorithm for creating .m4a files on "Voice Memos" is significantly more space efficient than my LPC algorithm.

### Notes for Demo

There are three main boolean options that can be adjusted at the top of the script: `realTimeOutput`, `recordAudioInput`, and `seeScope`.
	
`realTimeOutput` indicates whether or not the script will play the audio output in real time. If true, the audio plays as the script runs and does not save it as an external file. If false (default), the synthesized output is saved as "LPC_output.m4a".
	
`recordAudioInput` indicates whether or not the script allows the user to record their own voice for input. If true, the script records whatever speech the user says for approximately 5 seconds, saves it as "LPC_input.m4a", and then passes it through the LPC algorithm. If false (default), the user is prompted to enter a valid file name to use as input.
	
`seeScope` toggles the scope view of the synthesized signal and the curve produced by its LPC coefficients. It is automatically set to false.
	
Adjust these boolean values as you see fit and hit run to watch the synthesis.

### References

MathWorks. 2022. "LPC Analysis and Synthesis of Speech." MathWorks. Accessed April 7, 2022. [https://www.mathworks.com/help/dsp/ug/lpc-analysis-and-synthesis-of-speech.html](https://www.mathworks.com/help/dsp/ug/lpc-analysis-and-synthesis-of-speech.html).

O'Shaughnessy, Douglas. 1998. "Linear Predictive Coding." *IEEE Potentials* 7 (1): 29-32.

Sawant, G., A. Singh, K. Kadam, R. Mazarello, and P. Dumane. 2010. "Speech Synthesis Using LPC." In *Proceedings of the International Conference and Workshop of Emerging Trends in Technology*, 515-517.

